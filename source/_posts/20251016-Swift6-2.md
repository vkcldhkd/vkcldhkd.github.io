---
title: Swift6.2 변경점
date: 2025-10-16 18:17:22
category:
- Swift
tags:
- Swift6.2
---


# Swift 6.2 변경점 요약

---

## 주요 기능 & 개선점

### 1) 동시성(Concurrency) 관련 변화
- `nonisolated(nonsending)` 기본 동작 전환(제안): 비동기 함수가 기본적으로 호출자(caller)의 액터 격리를 상속하도록 바뀌는 방향의 제안이 있음
- **모듈 단위 기본 격리(default isolation) 설정(제안)**: 모듈 전체에 `@MainActor`와 같은 기본 격리를 지정하는 설정이 검토되고 있음.
- `@concurrent` 속성(제안): 함수 수준에서 격리 밖 동작을 의도적으로 표시할 수 있도록 하는 속성 제안이 있음.
- 동시성 진단/경고 개선: 데이터 경합(race) 관련 오탐 감소, 진단 메시지 가독성 향상 등 개발자 경험 개선이 포함.
- Global‑actor 격리 제어 강화(제안): 타입/프로토콜/컨포먼스 수준에서 global actor 격리를 더 명확히 지정·유도하려는 움직임이 있음.

### 2) 메모리/성능 관련
- **`InlineArray<N, Element>`**(제안): 고정 크기 배열을 스택에 담아 힙 할당/RC 비용을 줄이려는 타입 제안. (가변 연산 제약 존재)

### 3) 기타
- 소규모 표준 라이브러리/컴파일러 버그 수정 및 진단 향상.
- Xcode/툴체인 호환 업데이트.
- 공식 문서(Revision History 등) 반영.

---

## iOS 개발자가 특히 신경 써야 할 변화

| 변화 항목 | 영향/주의점 | 대응 방안 |
|---|---|---|
| 기본 액터 격리 변경 | UI 코드는 메인 스레드 보장이 중요. 기본 격리 변경 시 기존 async 코드의 컴파일 경고/오류 가능 | `@MainActor`/`@Sendable` 정비, UI 접근 경계 명시 |
| **`nonisolated(nonsending)` **기본 전환 | 호출자 격리 상속으로 동작이 달라질 수 있음 | `UIViewController`/ViewModel의 async 메서드에 `@MainActor`/`nonisolated` 명시 습관화 |
| **`@concurrent` **도입 | 선언만으로 격리 밖 실행 표기가 가능하나 오남용 시 복잡도↑ | CPU/IO 바운드 성능 구간에 한정 적용, 코드리뷰/문서화 |
| InlineArray | 픽셀/오디오 등 고정 버퍼 처리 시 성능 이득 가능 | 가변 연산 많으면 부적합. 이득/제약 검토 후 교체 |
| 진단 변화 | 경고/오류 메시지 정책이 바뀔 수 있음 | CI에서 Swift 6.2 툴체인으로 병행 빌드 테스트 |
| ObjC/C 연동 | 격리/동시성 변경이 브릿지 경계에 영향 | 브릿지 코드에 `@Sendable`/`@MainActor` 명시, 최신 라이브러리 사용 |

---

## 마이그레이션 가이드 & 주의사항

1. 스냅샷/프리뷰로 사전 검증: Swift 6.2 스냅샷 툴체인으로 로컬/CI 병행 빌드를 돌려 변화를 조기 포착.
2. 모듈별 점진 전환: `default isolation` 같은 넓은 범위 변경은 코어/피처 모듈 단위로 점진 적용.
3. 동시성 어노테이션 정비: `@MainActor`, `@preconcurrency`, `@unchecked Sendable`, `@Sendable` 등을 코드베이스 전반에 일관되게 적용.
4. 프리뷰/테스트 안정화: SwiftUI Previews, 단위테스트에서 네트워크/DB I/O 제거 및 Mock 대체.  
5. 서드파티 호환성 확인: SPM/CocoaPods 패키지들의 Swift 6.2 대응 릴리스를 추적하고 버전 핀 전략을 준비.  
6. 빌드 설정 검토: Xcode의 컴파일러/경고 처리 정책 변화에 맞춰 스킴·빌드 세팅을 업데이트.  

---

## 요약

- Swift 6.2는 동시성 모델의 사용성 개선이 핵심.  
- iOS 개발자는 UI 메인 액터 격리, 호출자 격리 상속, `@concurrent`의 올바른 사용, 그리고 고정 버퍼 처리 최적화(InlineArray)에 주목.  
- 대규모 코드베이스라면 스냅샷으로 조기 검증 → 모듈별 점진 전환 → 어노테이션 정비 루틴을 확인!


